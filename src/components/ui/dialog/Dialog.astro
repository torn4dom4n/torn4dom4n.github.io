---
import type { HTMLAttributes } from "astro/types";

type Props = HTMLAttributes<"div">;

const { class: className, ...rest } = Astro.props;
---

<div class:list={["dialog", className]} {...rest}>
	<slot />
</div>

<script>
	class DialogHandler {
		private trigger: HTMLButtonElement;
		private dialog: HTMLDialogElement;
		private closeButtons: NodeListOf<HTMLButtonElement>;
		private backdrop: HTMLElement;

		constructor(dialogWrapper: HTMLElement, dialogNumber: number) {
			this.dialog = dialogWrapper.querySelector("dialog")!;
			this.backdrop = dialogWrapper.querySelector(".dialog-backdrop")!;

			const tempTrigger = dialogWrapper.querySelector(
				".dialog-trigger",
			) as HTMLElement;
			this.trigger = tempTrigger?.hasAttribute("data-as-child")
				? (tempTrigger.firstElementChild as HTMLButtonElement)
				: (tempTrigger as HTMLButtonElement);

			const tempCloseButtons = dialogWrapper.querySelectorAll(
				".dialog-close",
			) as NodeListOf<HTMLElement>;
			tempCloseButtons.forEach((button: HTMLElement) => {
				if (button.hasAttribute("data-as-child")) {
					const childElement = button.firstElementChild;
					if (childElement) {
						childElement.classList.add("dialog-close");
						button.parentNode?.replaceChild(childElement, button);
					}
				}
			});

			this.closeButtons = dialogWrapper.querySelectorAll(
				".dialog-close",
			) as NodeListOf<HTMLButtonElement>;

			if (!this.trigger || !this.dialog || !this.backdrop) return;

			this.setupAccessibility(dialogNumber);
			this.setupEvents();
		}

		private setupAccessibility(dialogNumber: number): void {
			const firstHeading = this.dialog.querySelector("h1, h2, h3, h4, h5, h6");
			if (firstHeading) {
				firstHeading.id = `dialog${dialogNumber}-heading`;
				this.dialog.setAttribute("aria-labelledby", firstHeading.id);
			}
		}

		private setupEvents(): void {
			this.trigger?.addEventListener("click", () => this.open());

			this.closeButtons?.forEach((button) => {
				button.addEventListener("click", () => this.close());
			});

			this.dialog.addEventListener("click", (e) => {
				const dialogDimensions = this.dialog.getBoundingClientRect();
				const clickedInDialog =
					e.clientX >= dialogDimensions.left &&
					e.clientX <= dialogDimensions.right &&
					e.clientY >= dialogDimensions.top &&
					e.clientY <= dialogDimensions.bottom;

				if (!clickedInDialog) {
					this.close();
				}
			});

			this.dialog.addEventListener("keydown", (e) => {
				if (e.key === "Escape") {
					e.preventDefault();
					this.close();
				}
			});

			this.dialog.querySelectorAll("form").forEach((form) => {
				form.addEventListener("submit", (e) => {
					if (form.method === "dialog") {
						e.preventDefault();
						this.close();
					}
				});
			});
		}

		private open(): void {
			this.dialog.showModal();
			document.body.classList.add("overflow-hidden");
			this.backdrop.classList.remove("hidden");
			this.backdrop.dataset.state = "open";
			this.dialog.dataset.state = "open";
		}

		private close(): void {
			document.body.classList.remove("overflow-hidden");
			this.dialog.dataset.state = "closed";
			this.backdrop.dataset.state = "closed";
			this.backdrop.classList.add("hidden");
			this.dialog.close();
		}
	}

	const dialogInstances = new WeakMap<HTMLElement, DialogHandler>();

	const setupDialogs = () => {
		document.querySelectorAll(".dialog").forEach((dialogWrapper, idx) => {
			const wrapper = dialogWrapper as HTMLElement;
			if (!dialogInstances.has(wrapper)) {
				dialogInstances.set(wrapper, new DialogHandler(wrapper, idx));
			}
		});
	};

	setupDialogs();
	document.addEventListener("astro:after-swap", setupDialogs);
</script>
